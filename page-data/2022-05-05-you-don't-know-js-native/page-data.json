{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/2022-05-05-you-don't-know-js-native/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>네이티브는 내장 함수이다.</p>\n<p>네이티브 생성자의 결과는 원시값을 감싼 객체 래퍼이다.</p>\n<h2>내부 [[Class]]</h2>\n<p>typeof가 Object인 값에는 [[Class]]라는 내부 프로퍼티가 추가로 붙는다.</p>\n<p>이 프로퍼티는 접근은 불가능하고 Object.prototype.toString()라는 메서드에 값을 넣어 확인해볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//\"[object Array\"]</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">regex-literal</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//\"[object RegExp]\"</span></code></pre></div>\n<p>Null undefined는 내부 네이티브 생성자는 없지만 내부 [[Class]]값을 확인해보면 Null과 Undefined이다.</p>\n<p>그밖의 원시값들인 문자열, 숫자, 불리언은 박싱 과정을 거친다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//[\"object String\"]</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//[\"object Number\"]</span>\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//[\"object Boolean]\"</span></code></pre></div>\n<h2>래퍼 박싱</h2>\n<p>객체 래퍼는 아주 중요한 용도로 쓰인다. 자바스크립트 원시값에는 .length, .toString()으로 접근하려면 원시 값을 객체 래퍼로 감싸줘야하지만 자바스크립트는 원시 값을 알아서 박싱하므로 다음과 같은 코드가 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span>\na<span class=\"token punctuation\">.</span>length <span class=\"token comment\">// 3</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ABC'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>직접 객체 형태로 쓰기보다는 엔진이 알아서 암시적으로 박싱하게 하자.</p>\n<h3>객체 래퍼의 함정</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Oops'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//실행 x 엔진: \"객체 있는데?\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>false를 객체 래퍼로 감쌌지만 객체는 truthy이므로 실행되지 않는다.</p>\n<p>수동으로 원시값을 박싱하려면 Object()함수를 이용하면 된다. (new 키워드는 없음)</p>\n<h2>언박싱</h2>\n<p>객체 래퍼의 원시값은 valueOf() 메서드로 추출하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Boolean</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//\"abc\"</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//42</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//true</span></code></pre></div>\n<p>암시적인 언박싱이 일어나는 과정을 봐보자</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token string\">''</span> <span class=\"token comment\">//'b'에는 언박싱된 원시 값 'abc'이 대입된다.</span>\n\n<span class=\"token keyword\">typeof</span> a <span class=\"token comment\">//object</span>\n<span class=\"token keyword\">typeof</span> b <span class=\"token comment\">//string</span></code></pre></div>\n<h2>네이티브도 생성자다.</h2>\n<p>배열, 객체, 함수, 정규식 값은 리터럴 형태로 생성하는 것이 일반적이지만, 리터럴은 생성자 형식으로 만든 것과 동일한 종류의 객체를 생성한다.</p>\n<p>필요하지 않는다면 여전히 생성자는 사용하지 않는 것이 좋다.(리터럴 쓰란 말)</p>\n<h3>Array()</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// new 없어도 결과는 같다.</span>\na <span class=\"token comment\">// [1, 2, 3]</span>\n\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\nb <span class=\"token comment\">//[1, 2, 3]</span></code></pre></div>\n<p>Array 생성자에는 특별한 형식이 있는데 숫자를 하나만 받으면 그 숫자는 배열의 크기가 된다.</p>\n<p>슬롯에 값은 없는데 length를 보면 값이 있는 것 같은 배열이 되므로 빈 배열을 만들고 length를 지정해주는 게 더 나을 것이다.</p>\n<p>다음 코드를 실행해보고 차이점을 확인하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">//크롬 기준</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nc<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\na <span class=\"token comment\">// [empty × 3]</span>\nb <span class=\"token comment\">// [undefined, undefined, undefined]</span>\nc <span class=\"token comment\">// [empty × 3]</span></code></pre></div>\n<p>a와 b가 어떨때는 같아보이고 어떨때는 달라보인다 ㅜㅜ</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">a<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//\"--\"</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"-\"</span> <span class=\"token comment\">//\"--\"</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span>i</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[empty × 3] // a에는 슬롯이 없기 때문에 순회할 v와 i가 존재하지 않는다.</span>\nb<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span>i</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//[0, 1, 2] // b는 undefined가 존재한다.</span></code></pre></div>\n<p>join의 구현 로직은</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">fakeJoin</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> connector</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//length만큼 르프 반복</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> str <span class=\"token operator\">+=</span> connector\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> str <span class=\"token operator\">+=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token comment\">// undefined만 처리</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> str\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">fakeJoin</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//\"--\"</span></code></pre></div>\n<p>그렇다면 빈 slot말고 진짜 undefined 값 원소로 채워진 배열은(리터럴 x) 어떻게 생성할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> length<span class=\"token operator\">:</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\na <span class=\"token comment\">//[undefined, undefined, undefined]</span></code></pre></div>\n<h3>결론은 apply 등의 방법을 써서 빈 슬롯 배열을 만드는 것을 피하자.</h3>\n<h3>Object(), Function(), and RegExp()</h3>\n<p>일반적으로 이 세 생성자도 선택 사항이다. (분명한 의도없이는 사용을 자제하자)</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nc<span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">;</span>\nc<span class=\"token punctuation\">;</span> <span class=\"token comment\">//{foo: \"bar\"}</span>\n\n<span class=\"token keyword\">var</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>foo<span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nd<span class=\"token punctuation\">;</span> <span class=\"token comment\">//{foo: \"bar\"}</span>\n\n<span class=\"token keyword\">var</span> e <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"return a*2;\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">f</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> a<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> h <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"^a*b+\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"g\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^a*b+</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 자바스크립트 엔진이 실행 전 정규 표현식을 미리 컴파일한 후 캐시</span></code></pre></div>\n<p>썼을 때 기대값이 그렇게 높지 않다면 리터럴 위주로 사용하자!</p>\n<p>특히 정규 표현식은 리터럴 형식이 성능상 이점이 있다. 하지만 정규표현식 패턴을 동적으로 정의할 경우에는 RegExp()는 의미 있는 유틸리티이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Kyle'</span>\n<span class=\"token keyword\">var</span> namePattern <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\\\b(?:'</span> <span class=\"token operator\">+</span> name <span class=\"token operator\">+</span> <span class=\"token string\">')+\\\\b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">var</span> matches <span class=\"token operator\">=</span> someText<span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span>namePattern<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Date(), Error()</h3>\n<p>Date()와 Error() 생성자는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.</p>\n<p>date 객체 값은 new Date()로 생성한다. 이 생성자는 날짜/시각을 인자로 받는다.</p>\n<p>ES5이후에는 Date.now()가 있기 때문에 이를 사용하거나 이전 브라우저에는 getTime()을 이용하자!</p>\n<p>Error 생성자는 앞에 new가 있든 없든 결과는 같다.</p>\n<p>error 객체의 주 용도는 현재의 실행 스택 컨텍스트를 포착하여 객체에 담는 것이다. 이 실행 스택 콘텍스트는 함수 호출 스택, error 객체가 만들어진 줄 번호 등 디버깅에 도움이 될만한 정보들을 담고 있다.</p>\n<p>error 객체는 보통 throw 연산자와 함꼐 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'x를 안 주셨어요!'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Error 객채 인ㅅ그턴스에는 message 프로퍼티가 확실히 들어있고 type등 여러 프로퍼티는 포함되어있을 때도 있다.</p>\n<p>읽기 좋은 포맷으로 에러를 보기 위해서 toString()을 호출하는 것이 제일 좋다.</p>\n<h3>Symbol()</h3>\n<p>심벌은 ES6에서 처음 등장한 새로운 원시 값 타입이다. 심벌은 객체 프로퍼티로 충돌 없이 사용 가능한 “유일 값”이다.</p>\n<p>심벌은 프로퍼티명으로 사용할 수 있으나 코드나 콘솔창에서 심벌의 실제 값을 보거나 접근하는 것은 불가능하다.</p>\n<p>Symbol()은 앞에 new를 붙이면 에러가 난다.</p>\n<p>심벌은 객체가 아닌 원시값이다.</p>\n<h3>네이티브 프로토타입</h3>\n<p>내장 네이티브 생성자는 각자의 .prototype 객체를 가진다.</p>\n<p>prototype 객채에는 메서드들이 담겨있다.</p>\n<p>문자열 원시값을 확장한 것을 포함한 String 객체의 prototype에 있는 메서드를 알아보자.</p>\n<ul>\n<li>String#indexOf() 문자열에서 특정 문자의 위치를 검색</li>\n<li>String#charAt() 문자열에서 특정 위치의 문자를 반환</li>\n<li>String#substr(), String#substring, String#slice() 문자열의 일부를 새로운 문자열로 추출</li>\n<li>String#toUpperCase, String#toLowerCase() 대문자/소문자로 변환된 새로운 문자열 생성</li>\n<li>String#trim() 앞/뒤의 공란이 제거된 새로운 문자열 생성</li>\n</ul>\n<p>이중 문자열 값을 변경하는 메서드는 없다. 수정이 일어나면 늘 기존 값으로부터 새로운 값을 생성한다.</p>\n<p>“프로토타입 위임” 덕분에 모든 문자열이 이 메서드들을 같이 쓸 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">' abc '</span>\n\na<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//3</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \" ABC \"</span>\na<span class=\"token punctuation\">.</span><span class=\"token function\">trim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"abc\"</span></code></pre></div>\n<p>각 생성자 프로토타입마다 자신의 타입에 적합한 기능이 구현돼 있다.</p>\n<p>그러나 모든 네이티브 프로토타입이 모두 그렇게 평범한 것은 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">typeof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">//\"function\"</span>\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span><span class=\"token function\">prototype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//empty function!</span>\n\n<span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"/(?:)/\" -빈 정규표현식</span>\n<span class=\"token string\">'abc'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span> <span class=\"token comment\">//[\"\"]</span></code></pre></div>\n<p>프로토타입은 디폴트다.</p>\n<p>변수에 적절한 타입의 값이 할당되지 않은 상태에서 위처럼 Function, RegExp, Array의 prototype 즉 타입만 가진 빈 값들은 모두 멋진 디폴트 값이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">isThisCool</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">vals<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">,</span> rx</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  vals <span class=\"token operator\">=</span> vals <span class=\"token operator\">||</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">//값이 없으면 빈 타입</span>\n  fn <span class=\"token operator\">=</span> fn <span class=\"token operator\">||</span> nFunction<span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">//값이 없으면 빈 타입</span>\n  rx <span class=\"token operator\">=</span> rx <span class=\"token operator\">||</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">//값이 없으면 빈 타입</span>\n  <span class=\"token keyword\">return</span> rx<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>vals<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">isThisCool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//true 정규표현식 만족</span>\n\n<span class=\"token function\">isThisCool</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">D</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token comment\">//false 숫자아님</span></code></pre></div>\n<p>이후에 변경될 값이라면 Array.prototype을 사용하는 일을 자제하자. prototype도 수정돼 의도치 않은 문제가 생길 수 있다.</p>\n<h2>정리</h2>\n<p>자바스크립트는 원시 값을 감싸는 개체 래퍼, 즉 네이티브를 제공한다. 객체 래퍼에는 타입별로 기능이 내장돼있어 편리한 사용이 가능하다.</p>\n<p>“abc”같은 단순 스칼라 원시 값이 있을 떄, 이값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시값을 박싱하여 필요한 프로퍼티와 메서드를 사용할 수 있게 도와준다.</p>","frontmatter":{"title":"YOU DON’T KNOW JS (3장 네이티브)","summary":"카일 심슨의 YOU DON'T KNOW JS 3장 네이티브 정리","date":"2022.05.05.","categories":["js"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAApElEQVQoz2P4f6uGbMRAE83/blb/vVH972bNP3Jsvlf3/349iHG7lgTNIKvu1L44VvjkcP7PK5XfL1fg0o9F898b1f8fNx5aHr+wy29Gk/eehTH/HzT8vVlNWPO/m1APz2n12bMwek6b7/RGL2I1Q9Htmpu7sj6cLb2zJ/vD2dL/d2r/kRZgDxv+36n9/6D+/93a/zdJDG1wPFX/AccWfRMJMZoBADQoGw79AEcAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/8add42706d9936c8c0866ce13efe8b0a/2ee73/vanilla.png","srcSet":"/static/8add42706d9936c8c0866ce13efe8b0a/10d63/vanilla.png 71w,\n/static/8add42706d9936c8c0866ce13efe8b0a/e45ee/vanilla.png 142w,\n/static/8add42706d9936c8c0866ce13efe8b0a/2ee73/vanilla.png 284w","sizes":"(min-width: 284px) 284px, 100vw"},"sources":[{"srcSet":"/static/8add42706d9936c8c0866ce13efe8b0a/1d6d0/vanilla.webp 71w,\n/static/8add42706d9936c8c0866ce13efe8b0a/147bb/vanilla.webp 142w,\n/static/8add42706d9936c8c0866ce13efe8b0a/033a8/vanilla.webp 284w","type":"image/webp","sizes":"(min-width: 284px) 284px, 100vw"}]},"width":284,"height":177}},"publicURL":"/static/8add42706d9936c8c0866ce13efe8b0a/vanilla.png"}}}}]}},"pageContext":{"slug":"/2022-05-05-you-don't-know-js-native/"}},
    "staticQueryHashes": []}